---
title: "MA386 Coding Cookbook"
subtitle: "04 - Programming"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    highlight: tango
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(tidyverse)
library(learnr)

knitr::opts_chunk$set(echo = FALSE)
learnr::tutorial_options(exercise.cap = "Exercise")
```

```{css, echo=FALSE}
.tipbox {
  padding: 1em 1em 1em 1em;
  border: 1px solid black;
  border-radius: 10px;
  box-shadow: 2px 2px #888888;
}

.keyidea {
  border: 1px solid #54585A;
  background: #4F758B;
  color: white;
}

.tip {
  background: lightyellow;
}

.alert {
  background: #E87722;
  color: white;
}

.title{
  color: #800000;
  background: none;
}

.subtitle{
  color: #696969;
  font-style: normal;
}

.author{
  font-weight: normal;
  font-style: italic;
}

h2{
  color: white;
  background-color: #800000;
}

h3{
  color: #800000;
  border-bottom: thick solid #696969;
}

h4{
  color: #800000;
}

blockquote {
  font-size: inherit;
  padding: 0px 20px;
}
```


Data is rarely in the format needed for an analysis.  The process of manipulating data (wrangling) necessarily involves programming.  Thus far, we have made simple changes to the data using built-in functions within the `tidyverse`.  In this section, we discuss writing custom functions and applying functions efficiently within various data structures.  We will discuss the benefit of vectorizing operations and tools for implementing vectorized code.

Throughout this section, we will make use of functions from the following packages:

- `tidyverse` (particularly `magrittr` and `purrr`)


## Chained Operations
By this point, it should be clear that a computational task rarely involves a single step using a single function.  Instead, we perform a series of steps.  This series results in our chaining together several operations.  While this can be accomplished in multiple lines of code, the pipe operator (`%>%`) can help make code more readable.  

<div class = "tipbox alert">
__Prerequisites:__ Before completing this section, you should complete the following:

- Read the following chapters in _R for Data Science_: 18
</div>

The text can be summarized as saying, think of the pipe operator as saying "take the result of the left-side and inject it into the function on the right-side as the first argument."  This last component is critical: it will be inserted as the _first_ argument every time.  If interested, you can see the `wrapr` package for a discussion of other pipe operators and implementations within R.


### Exercise: Eliminating Intermediate Steps
> When intermediate steps are not of interest, storing them is both inefficient and can result in confusing code.  The following code chunk has several intermediate steps of unimportance; alter the code chunk to obtain the same result using the pipe operator.

```{r s4-ex-pipe1, exercise=TRUE, exercise.eval=TRUE}
# Sort storms by date
storms_ordered <- arrange(storms, year, month, day, hour)

# Change the units on wind
storms_update <- mutate(storms_ordered, 
                        wind_mph = 1.15078 * wind)

# Group storms by status
storms_grouped <- group_by(storms_update, status)

# Summarize wind speed
summarise(storms_grouped, 
          `Avg Wind Speed (mph)` = mean(wind_mph))
```

```{r s4-ex-pipe1-solution}
storms %>%
  arrange(year, month, day, hour) %>%
  mutate(wind_mph = 1.15078 * wind) %>%
  group_by(status) %>%
  summarise(`Avg Wind Speed (mph)` = mean(wind_mph))
```


In the above, we eliminated intermediate steps.  We can also eliminate nesting to make it more readable.

### Exercise: Eliminating Function Nesting
> The following code chunk nests several functions together.  Alter the code chunk to obtain the same result after eliminating the nesting by using the pipe operator.

```{r s4-ex-pipe2, exercise=TRUE, exercise.eval=TRUE}
summarise(
  mutate(
    filter(
      storms,
      category == 0
    ),
    pressure = 100 * pressure
  ),
  `Max Pressure (pascals)` = max(pressure)
)
```

```{r s4-ex-pipe2-solution}
storms %>%
  filter(category == 0) %>%
  mutate(pressure = 100 * pressure) %>%
  summarise(`Max Pressure (pascals)` = max(pressure))
```

Admittedly, the use of the pipe operator is a matter of preference.  The authors argue it produces more readable code.


## Writing Functions
R's vast user-base has led to a vast number of packages, each containing a suite of useful functions.  However, inevitably you will encounter a task which is not pre-packaged or for which you need a custom solution.  When we perform the same task repeatedly, it is helpful (for debugging purposes and readability) to package the code as a function (instead of leaving it as a loose script).

In this section, we will discuss the basics of writing a function in R and also the concept of vectorization.

<div class = "tipbox alert">
__Prerequisites:__ Before completing this section, you should complete the following:

- Read the following chapters in _R for Data Science_: 19
- Watch [Benefits of Vectorization](https://rose-hulman.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=48c05770-3284-4f58-849a-ac2101057bdf) video.
</div>

In a previous lesson, we used the Haversine distance formula in order to compute the distance (in kilometers) the eye of a tropical storm had traveled between 6-hour observations.  The Haversine distance formula is defined as

\[
\begin{aligned}
  a &= \sin^2 \left(\Delta \phi / 2\right) + 
    \cos \left(\phi_1\right) \cdot \cos \left(\phi_2\right) \cdot \sin^2 \left(\Delta \lambda / 2 \right) \\
  c &= 2 \cdot \text{atan2} \left(\sqrt{a}, \sqrt{1-a}\right) \\
  d &= R \cdot c
\end{aligned}
\]

where \(\phi\) is latitude, \(\lambda\) is longitude, and \(R\) is the earth's radius (approximately 6371 kilometers).  Note that the latitude and longitude must be expressed in radians for the above expression but are often stored as signed decimal degrees (where negative values indicate west/south).  

This can be implemented in the following code chunk (assuming that `storms` is already appropriately sorted and grouped by storm).

```{r s4-example-haversine, echo=TRUE, eval=FALSE}
storms_distance <-
  mutate(storms,
         lat_rad = lat * pi / 180,
         long_rad = long * pi / 180,
         lag_lat = lag(lat_rad),
         lag_long = lag(long_rad),
         a = (sin(0.5 * (lat_rad - lag_lat)))^2 + 
           cos(lat_rad) * cos(lag_lat) * (sin(0.5 * (long_rad - lag_long)))^2,
         distance = 6371 * 2 * atan2(sqrt(a), sqrt(1 - a)))
```

If we only perform this operation once during an analysis, it may be reasonable to script it as above.  However, it produces extraneous variables that are unnecessary (lagged values and `a` for example).  More, if we perform this computation multiple times in an analysis, then we are less likely to make a mistake if we package this as a function.  Our goal in this section is to build this function in stages.

While this may seem tedious, we should remember that functions are rarely written in a single pass.  The construction of a function should be iterative, with checks placed at various points to ensure we are dubugging regularly (debugging one line of code is infinitely easier than debugging one hundred lines of code).

All function definitions are similar:

```
function_name <- function(arguments) {
  body of function
}
```

Note that we do not need to specify the type of object being returned (this makes building a function in stages very easy in R).

### Exercise: Function Definition
> Define a function called `haversine_distance` which takes four aguments: `lat1`, `lat2`, `lon1`, and `lon2`.  At this point, the function should have no body.

```{r s4-ex-haversine-defn, exercise=TRUE}
function_name <- function(arguments) {
}
```

```{r s4-ex-haversine-defn-solution}
haversine_distance <- function(lat1, lat2, lon1, lon2) {
}
```


The body of a function can contain any valid R code.  However, the _scope_ of the function (what it has access to) can be tricky.  When writing a function, assume you only have access to the arguments that have been passed to the function as well as anything created within the function.  Keep in mind that you are not updating the actual values passed to the function; you are altering "copies" of those elements which have the names of the arguments in the function.

### Exercise: Converting Latitude/Longitude
> Update the function `haversine_distance` to convert the latitude and longitude values from degrees to radians.  The function should still not return any value.

```{r s4-ex-haversine-convert, ref.label="s4-ex-haversine-defn-solution", exercise=TRUE}
```

```{r s4-ex-haversine-convert-solution}
haversine_distance <- function(lat1, lat2, lon1, lon2) {
  # convert latitude/longitude from degrees to radians
  lat1 <- lat1 * pi / 180
  lat2 <- lat2 * pi / 180
  lon1 <- lon1 * pi / 180
  lon2 <- lon2 * pi / 180
}
```

We note that the process of converting degrees to radians was a process that was repeated multiple times.  It might be reasonable to embed this within a function itself:

```{r s4-example-conversion, echo=TRUE, eval=FALSE}
deg_to_rad <- function(x) {
  x * pi / 180
}
```

This short function reveals something we need to keep in mind as we write our own functions.  The return value of a function need not be explicitly defined.  The last expression evaluated and not saved is returned by the function.

### Exercise: Intermediate Steps
> Update the function `haversine_distance` to compute the value `a` from the definition of the Haversine formula.  The function should not return any value.

```{r s4-ex-haversine-a, ref.label="s4-ex-haversine-convert-solution", exercise=TRUE}
```

```{r s4-ex-haversine-a-solution}
haversine_distance <- function(lat1, lat2, lon1, lon2) {
  # convert latitude/longitude from degrees to radians
  lat1 <- lat1 * pi / 180
  lat2 <- lat2 * pi / 180
  lon1 <- lon1 * pi / 180
  lon2 <- lon2 * pi / 180
  
  # computation of intermediate value
  a <- (sin(0.5 * (lat2 - lat1)))^2 + 
           cos(lat1) * cos(lat2) * (sin(0.5 * (lon2 - lon1)))^2
}
```


### Exercise: Complete Function
> Update the function `haversine_distance` to return the the distance between the two coordinates provided.

```{r s4-ex-haversine-return, ref.label="s4-ex-haversine-a-solution", exercise=TRUE}
```

```{r s4-ex-haversine-return-solution}
haversine_distance <- function(lat1, lat2, lon1, lon2) {
  # convert latitude/longitude from degrees to radians
  lat1 <- lat1 * pi / 180
  lat2 <- lat2 * pi / 180
  lon1 <- lon1 * pi / 180
  lon2 <- lon2 * pi / 180
  
  # computation of intermediate value
  a <- (sin(0.5 * (lat2 - lat1)))^2 + 
           cos(lat1) * cos(lat2) * (sin(0.5 * (lon2 - lon1)))^2
  
  # return distance
  6371 * 2 * atan2(sqrt(a), sqrt(1 - a))
}
```


With our completed function, we can now compute the distance the storm travels.  In this code chunk, we also ensure the data is appropriately arranged and grouped.

```{r s4-example-haversine-piped, echo=TRUE, eval=FALSE}
storms %>%
  arrange(name, year, month, day, hour) %>%
  group_by(name) %>%
  mutate(distance = haversine_distance(lag(lat), lat, lag(long), long))
```

We sill need to lag the coordinates in order to create two coordinates being compared; however, note how much cleaner this is than the original script.  

If you are looking at this solution and are new to R, you may be amazed that it worked.  When writing the `haversine_distance` function, we did not treat the arguments as vectors; we considered them as individual values.  This is the benefit of _vectorization_.  Nothing in our function definition suggested that the arguments needed to be scalars; every computation would work if the arguments are vectors.  This worked in this example because of R's element-wise computation.  Specifically, in the above `atan2(sqrt(a), sqrt(1 - a))`, this function is evaluated for each element of the vector `a` element-wise.  

<div class = "tipbox tip">
Watch out for what is known as _recycling_ in R.  For example, examine the output to the following code chunk, and note that no warning messages are printed when this is run.
</div>

```{r s4-example-recycling, echo=TRUE, eval=TRUE}
x <- c(1, 2, 3)
y <- c(4, 5, 6, 7, 8, 9)

x + y
```

Most arithmetic operations and functions available are already vectorized.  When writing your own code, vectorization generally becomes something you have to think about when you have conditional arguments.  In particular if-else statements are not naturally vectorized.  However, there are two common alternatives: `ifelse()` and `case_when()` (the former being base R and the latter being available in the `tidyverse` package).

### Exercise: Vectorization
> The following code chunk defines a function takes a temperature (in degrees Celcius) and returns a qualifier of the temperature.  As currently written, the result is not what we would expect (and a warning message is produced) if a vector of values is passed.  Alter the function definition to return a vector of corresponding qualifiers if a vector is passed.

```{r s4-ex-vectorization, exercise=TRUE, exercise.eval=FALSE}
temperature_qualifier <- function(temp) {
  if (temp <= 0) {
    "freezing"
  } else if (temp <= 10) {
    "cold"
  } else if (temp <= 20) {
    "cool"
  } else if (temp <= 30) {
    "warm"
  } else {
    "hot"
  }
}

temperature_qualifier(c(5, 25, 35))
```

```{r s4-ex-vectorization-solution}
temperature_qualifier <- function(temp) {
  dplyr::case_when(
    temp <= 0 ~ "freezing",
    temp <= 10 ~ "cold",
    temp <= 20 ~ "cool",
    temp <= 30 ~ "warm",
    TRUE ~ "hot"
  )
}

temperature_qualifier(c(5, 25, 35))
```

In the solution to this exercise, we make use of the `::` notation to reference a particular function.  When calling a function from a package within a personal function, it can be helpful to denote exactly which package the function you are calling resides (this is especially true when different packages provide conflicting definitions of the same function).  


## Iteration
Compared to some other languages, there is less of a need for iteration within R due to vectorization.  Since a vector is the foundational structure in R and most functions vectorize their inputs.  That is, most computations have a built-in loop.  However, there are some instances in which we need to iterate over a _list_ of objects (or even a vector in some cases for which vectorization is not easily established).

In this section, we discuss the `purrr` package implementation of iteration.

<div class = "tipbox alert">
__Prerequisites:__ Before completing this section, you should complete the following:

- Read the following chapters in _R for Data Science_: 21
</div>

In order to really understand when to best use loops, we must first understand a _list_.  A list in R is an array (collection) of objects of potentially different types.  That is, a vector has all integers or all boolean values.  However, list can contain datasets as well as integers and booleans.

```{r s4-example-list, echo=TRUE, eval=FALSE}
example_list <- list(
  Element1 = c(1, 2, 3),
  Element2 = "hello",
  Element3 = storms
)
```

In this example, the first element is a vector (of doubles), the second element a single string, and the last element an entire tibble (dataset).

The `map` functions create a built-in loop over the elements of their first argument (generally a list, though this need not be the case).


### Exercise: Loops and Maps
> The following code chunk defines a function which takes an integer and returns the factors of that integer (albeit not the most efficient way).  Alter the code to work using a `map` function instead of using a for-loop.  

```{r s4-ex-map, exercise=TRUE, exercise.eval=TRUE}
factors <- function(x) {
  factors <- vector("list", length = length(x))
  
  for (i in 1:length(x)) {
    # list all integers up to and including x
    y <- seq(x[i])
    
    # keep only those integers which divide evenly into x
    # x %% y indicates "x modulo y"
    factors[[i]] <- y[(x[i] %% y) == 0]
  }
  
  factors
}

factors(c(3, 10, 25))
```

```{r s4-ex-map-solution}
factors <- function(x) {
  map(x, ~ seq(.x)[(.x %% seq(.x)) == 0])
}

factors(c(3, 10, 25))
```

Admittedly, the use of a for-loop or the `map` functions is a preference.
